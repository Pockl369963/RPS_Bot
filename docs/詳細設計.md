# 詳細設計書：最強のじゃんけんBot "Evolutionary RPS" (Ver 2.0)
毎回コピーして使う
reference@詳細タスク.md, reference@詳細設計.md
## 0. 開発メソドロジー (Antigravity-Driven Development)

本プロジェクトでは、Google Deepmindが開発した高度なAIエージェント「Antigravity」をメインエンジニア・アーキテクトとして据え、AI駆動開発（AIDD）を実践する。

### 0.1 Spec-Driven Development (SpecDD)
*   **Single Source of Truth**: 本詳細設計書（`詳細設計.md`）を正とし、全ての実装はこの仕様に基づき行う。
*   **Iterative Specification**: 実装中に判明した仕様の不備や変更は、即座に本ドキュメントに反映し、常に最新の状態を保つ。

### 0.2 AI-Enhanced TDD (AI-TDD)
*   **Test First**: 実装前に必ずテストコード（失敗するテスト）を作成する。
*   **Cycle**: Red (テスト作成) -> Green (最小限の実装) -> Refactor (最適化) のサイクルを回す。
*   **Automated Review**: 生成されたコードは、セキュリティチェックリストに基づき厳格にレビューする。

---

## 1. システムアーキテクチャ

### 1.1 全体構成
本システムは、Djangoフレームワークを用いたWebアプリケーションとして構築する。
クライアントサイド（ブラウザ）とサーバーサイド（Django）がAPIを通じて通信し、じゃんけんの対戦と学習を行う。

*   **Client**: HTML5, JavaScript (Fetch API), Tailwind CSS
    *   ユーザーインターフェースの描画
    *   ユーザーの入力（手）の送信
    *   ゲーム結果と演出の反映
*   **Server**: Python 3.10+, Django
    *   **Game Logic**: じゃんけんの勝敗判定
    *   **AI Engine**: アンサンブルアルゴリズムによる次の手の予測
    *   **Data Store**: SQLiteによる戦績・ログの保存

### 1.2 ディレクトリ構成案
```text
RPS_project/
├── pyproject.toml
├── src/
│   ├── manage.py
│   ├── rps_project/          # プロジェクト設定
│   │   ├── settings.py
│   │   ├── urls.py
│   │   └── ...
│   └── game/                 # ゲームアプリ
│       ├── migrations/
│       ├── static/
│       │   ├── css/
│       │   └── js/
│       │       └── game.js   # フロントエンドロジック
│       ├── templates/
│       │   └── game/
│       │       └── index.html # メイン画面
│       ├── models.py         # DBモデル
│       ├── views.py          # APIエンドポイント
│       ├── urls.py
│       └── ai/               # AIロジック格納ディレクトリ
│           ├── __init__.py
│           ├── predictors.py # 各予測器 (Markov, Pattern, etc.)
│           ├── strategy.py   # メタ戦略 (Iocaine, Selector)
│           └── utils.py      # ユーティリティ (LZWなど)
├── docs/                     # ドキュメント
│   ├── アーキテクチャ.md
│   ├── 詳細設計.md
│   └── ...
└── requirements.txt
```

---

## 2. データベース設計 (SQLite)

### 2.1 ER図 (概念)
`Player` (1) -- (N) `GameLog`

### 2.2 テーブル定義

#### 2.2.1 Player (ユーザー管理)
ユーザーを識別し、通算戦績を管理する。

| カラム名 | データ型 | 制約 | 説明 |
| :--- | :--- | :--- | :--- |
| `id` | UUID | PK | クライアントのCookieに保存されるUUID |
| `created_at` | DateTime | Auto Now Add | 初回アクセス日時 |
| `total_games` | Integer | Default 0 | 総対戦数 |
| `wins` | Integer | Default 0 | プレイヤーの勝利数 |
| `losses` | Integer | Default 0 | プレイヤーの敗北数 |
| `draws` | Integer | Default 0 | 引き分け数 |
| `current_phase` | Integer | Default 1 | 現在のフェーズ (1-5) |

#### 2.2.2 GameLog (対戦ログ)
1手ごとの詳細な記録。AIの学習データとしても使用する。

| カラム名 | データ型 | 制約 | 説明 |
| :--- | :--- | :--- | :--- |
| `id` | AutoField | PK | ログID |
| `player` | ForeignKey | Player | 紐づくプレイヤー |
| `round_number` | Integer | | そのプレイヤーにとっての何戦目か |
| `user_move` | String | "R", "P", "S" | ユーザーの手 |
| `ai_move` | String | "R", "P", "S" | AIの手 |
| `result` | String | "win", "lose", "draw" | ユーザーから見た結果 |
| `strategy_used` | String | | 採用された戦略名 (例: "Markov_P1", "Safety_A") |
| `timestamp` | DateTime | Auto Now Add | 対戦日時 |

---

## 3. アルゴリズム詳細設計

### 3.1 予測器 (Predictors)
`game/ai/predictors.py` に実装。各クラスは共通のインターフェース `predict(history)` を持つ。

1.  **Random**: `random.choice(['R', 'P', 'S'])`
2.  **Markov Chain**:
    *   **1st Order**: 直前の1手から次の手を予測。遷移行列を更新しながら確率的に選択。
    *   **2nd Order**: 直前の2手の並びから次の手を予測。
3.  **Pattern Matcher**:
    *   過去の全履歴を文字列化し、直近3〜5手のパターンと一致する最長の部分列を検索。その直後の手を予測とする。
4.  **Compression (LZW)**:
    *   履歴データに対するLZW圧縮の辞書を利用し、予測を行う（複雑度が高い系列の次を予測）。
5.  **Psychology (WSLS - Win-Stay, Lose-Shift)**:
    *   前回の結果がAI勝ち(User負け) -> Userは手を変える(Shift)と予測。
    *   前回の結果がAI負け(User勝ち) -> Userは手を変えない(Stay)と予測。
6.  **Frequency Analysis**:
    *   直近10手の頻度を集計。最も多い手に対して勝てる手を出す（バイアス利用）。
7.  **RNN (Recurrent Neural Network)**:
    *   **Architecture**: LSTM (Long Short-Term Memory).
    *   **Input**: 直近の対戦履歴（Userの手、AIの手、勝敗など）のシーケンス（One-hot encoding）。
    *   **Output**: 次の予測手の確率分布。
    *   **Activation**: データ数が一定数（例: 50手）を超えてから予測に参加する。
    *   **Learning**: オンライン学習（対戦ごとにモデルを更新）。

### 3.2 メタ戦略 (Iocaine Logic)
`game/ai/strategy.py` に実装。

*   **P0 (Naive)**: 各予測器が「ユーザーが出す」と予測した手に対して、勝つ手を出す。
*   **P1 (Second-guess)**: ユーザーが「AIがP0で来ること」を読んで裏をかくと仮定し、その裏（P0の予測に対する負け手＝ユーザーの勝ち手）に対して勝つ手を出す。
*   **Selector**:
    *   各予測器(x P0/P1)の過去の的中率（仮想スコア）を保持。
    *   次の一手を決定する際、最もスコアが高い戦略を採用する。

### 3.3 安全策 (Safety Mechanisms)
`Selector` の決定前に割り込む緊急ロジック。

*   **Safety A (Anti-Spam)**:
    *   `history[-10:]` をチェック。同一の手が8回以上(80%)あれば、その手に勝つ手を強制選択。
    *   `strategy_used` には "Safety_AntiSpam" を記録。
*   **Safety B (Stop-Loss)**:
    *   `history[-20:]` のAI勝率を計算。25%以下(5勝未満)なら、強制的に `Random` を選択。
    *   `strategy_used` には "Safety_Random" を記録。

---

## 4. API インターフェース設計

### 4.1 Play API
*   **Endpoint**: `POST /api/play/`
*   **Request Body**:
    ```json
    {
      "player_id": "uuid-string",
      "move": "R" // or "P", "S"
    }
    ```
*   **Response Body**:
    ```json
    {
      "result": "win", // user's result
      "ai_move": "S",
      "stats": {
        "wins": 10,
        "losses": 5,
        "draws": 2,
        "total": 17,
        "win_rate": 0.58
      },
      "phase": 3, // Current Phase (1-5)
      "strategy": "Markov_P1" // Debug info (optional to show in frontend)
    }
    ```

### 4.2 Reset API
*   **Endpoint**: `POST /api/reset/`
*   **Request Body**:
    ```json
    {
      "player_id": "uuid-string"
    }
    ```
*   **Response Body**:
    ```json
    {
      "status": "success",
      "message": "Memory erased."
    }
    ```

---

## 5. UI/UX デザイン詳細

### 5.1 画面構成
*   **Header**: タイトル "Evolutionary RPS"
*   **Main Area**:
    *   **Opponent (AI)**: AIの手を表示（最初は「？」、判定後にアイコン表示）。
    *   **Status**: 現在のフェーズ名、勝率、対戦数。
    *   **Player (User)**: グー・チョキ・パーの3ボタン。
*   **Footer**: リセットボタン、デバッグ情報（開発中のみ）。

### 5.2 ダイナミック・テーマ (Tailwind CSS Classes)
JavaScriptで `body` またはラッパー要素のクラスを操作し、フェーズごとにテーマを切り替える。

| Phase | Theme Name | Background | Text | Accent |
| :--- | :--- | :--- | :--- | :--- |
| **1** | Observation | `bg-white` | `text-gray-800` | `border-gray-200` |
| **2** | Analysis | `bg-gray-100` | `text-gray-900` | `border-gray-400` |
| **3** | Conflict | `bg-gray-600` | `text-white` | `border-gray-500` |
| **4** | Pressure | `bg-slate-800` | `text-slate-200` | `border-indigo-500` |
| **5** | Domination | `bg-black` | `text-red-600` | `border-red-900` |

### 5.3 演出ロジック
*   **Phase Transition**: 対戦終了時にAPIから返却された `phase` が前回と異なる場合、CSS transitionを用いて背景色をゆっくり変化させる（duration-1000など）。
*   **Glitch Effect**: `Safety_Random` 発動時（APIレスポンスの `strategy` で判定可能、または `phase` とは別のフラグで返す）、画面全体を一瞬ずらすCSSアニメーションを発火させる。

---

## 6. Antigravity Guidelines (Editor Rules)

本プロジェクトの開発を担当するAIエージェント「Antigravity」は、以下のガイドラインを「法律」として遵守しなければならない。

### 6.1 役割と責任
*   **Role**: Senior Engineer & Architect
*   **Responsibility**: 単にコードを書くだけでなく、システム全体の整合性、セキュリティ、保守性を担保する。
*   **Autonomy**: 指示待ちにならず、必要なリファクタリングや改善提案を能動的に行う。

### 6.2 技術スタックの厳格化
以下のスタック以外を使用してはならない。
*   **Framework**: Django 5.2 LTS, Python 3.10+
*   **Frontend**: Vanilla JS (Fetch API), Tailwind CSS (CDN)
*   **Database**: SQLite
*   **ML Library**: PyTorch, NumPy
*   **Package Manager**: uv

### 6.3 コーディング規約 (Quality Assurance)
*   **Type Hinting**: Pythonコードには必ず型ヒントを付与する。
*   **Docstrings**: Google StyleのDocstringを記述する。
*   **Testing**: `pytest` を使用し、単体テストを必須とする。
*   **Security**:
    *   ユーザー入力は必ずバリデーションを行う。
    *   CSRF対策を徹底する。
    *   外部ライブラリの無断追加を禁止する。

### 6.4 ワークフロー (Artifact Management)
*   **task.md**: 進捗管理のマスター。タスクの開始・完了を必ず記録する。
*   **implementation_plan.md**: 実装前の設計図。ユーザーの承認を得てから実装に移る。
*   **walkthrough.md**: 実装後の証明書。テスト結果やスクリーンショットを記録する。

---

## 7. 今後のタスク (Antigravity Workflow)

1.  **Project Initialization**: `uv` を用いたDjangoプロジェクトのセットアップ。
2.  **Model Implementation (TDD)**
    *   [ ] `Player` モデルのテスト作成 -> 実装
    *   [ ] `GameLog` モデルのテスト作成 -> 実装
3.  **Algorithm Implementation (TDD)**
    *   [ ] `Predictor` インターフェースの定義
    *   [ ] 各予測ロジック（Random, Markov, etc.）のテスト作成 -> 実装
    *   [ ] `Strategy` (Selector) のテスト作成 -> 実装
4.  **API Implementation (TDD)**
    *   [ ] `/api/play/` の結合テスト作成 -> ビュー実装
    *   [ ] `/api/reset/` の結合テスト作成 -> ビュー実装
5.  **Frontend Implementation**
    *   [ ] `index.html` の構造作成
    *   [ ] `game.js` のロジック実装（API連携）
    *   [ ] Tailwind CSS によるダイナミックテーマの実装
6.  **Verification & Deploy**
    *   [ ] 全体テスト実行
    *   [ ] PythonAnywhereへのデプロイ
